<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tengstrand's Blog</title>
  <link href="https://tengstrand.github.io/blog/atom.xml" rel="self"/>
  <link href="https://tengstrand.github.io/blog/"/>
  <updated>2025-12-06T03:53:08+00:00</updated>
  <id>https://tengstrand.github.io/blog/</id>
  <author>
    <name>Joakim Tengstrand</name>
  </author>
  <entry>
    <id>https://tengstrand.github.io/blog/2019-09-14-the-origin-of-complexity.html</id>
    <link href="https://tengstrand.github.io/blog/2019-09-14-the-origin-of-complexity.html"/>
    <title>The origin of complexity</title>
    <updated>2019-09-14T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<div><img src="assets/2019-09-14-the-origin-of-complexity/gordian-knot.webp" alt="A golden Gordian knot symbolizing the intertwined nature of complexity" style="width: 30%; max-width: 420px; height: auto;"><p>Writing software is hard.</p><p>There are so many things to deal with, so many moving parts and things that can go wrong that it is easy to get lost. It&apos;s not only about building the <em>right thing</em>, but also about building the <em>thing right</em>.</p><p>As a reaction to that, the list of tips on how to best develop software has constantly grown over the years. Sometimes the tips have been quite helpful but others have been contradictory.</p><!-- end-of-preview --><p>We have learned to not repeat ourselves, avoid mutable state, use pure functions, use interfaces, use polymorphism, prefer composition, use declarative style, avoid temporal coupling, work in small teams, make small commits, avoid long lived branches, test our code, and so on.</p><p>But wouldn&apos;t it be great if we could find one single, simple principle, that is easy to understand and that helps us to reason about software?</p><p>Let&apos;s rewrite the list and add <em>why</em> to get a hint:</p><ul><li><em>Don&apos;t repeat yourself</em> — because that adds coordination</li><li><em>Make it small</em> — because that reduces coordination</li><li><em>Avoid mutable state</em> — because it adds coordination</li><li><em>Use pure functions</em> — because they reduce coordination</li><li><em>Use interfaces</em> — because they reduce coordination</li><li><em>Use polymorphism</em> — because it reduces coordination</li><li><em>Prefer composition</em> — because it reduces coordination</li><li><em>Use declarative style</em> — because it reduces coordination</li><li><em>Avoid temporal coupling</em> — because it introduces coordination</li><li><em>Work in small teams</em> — because it reduces coordination</li><li><em>Make small commits</em> — because it reduces coordination</li><li><em>Avoid long lived branches</em> — because they increase coordination</li><li><em>Test your code</em> — to catch coordination that wasn&apos;t done correctly!</li></ul><p>As you can see, it&apos;s all about <em>coordination</em>!</p><p>Now you may think, what&apos;s wrong with coordination?</p><p>The problem with coordination is that it <em>adds complexity</em> to our systems which make them harder to change and work with. Let&apos;s look at an example.</p><p>Here we have inserted a heading in a simple text editor:</p><pre style="font-family: 'Courier New', Courier, monospace; font-size: 1.1em;">My heading
==========</pre><p>The problem with this is that if we change the heading,</p><pre style="font-family: 'Courier New', Courier, monospace; font-size: 1.1em;">Your heading
==========</pre><p>we also need to update the row below, by adding more = characters. The consequence is that we have introduced <em>coordination</em> that needs to be <em>addressed by a human being</em>. This may be a small problem here, because the missing equal signs are easy to spot and fix, but that&apos;s not always the case.</p><p>Another way to put it is that we have <em>failed to automate</em> the task, by <em>introducing manual work</em> instead of letting the computer do the job for us.</p><p>The solution is to switch to a more advanced text editor, like this:</p><pre style="font-family: 'Courier New', Courier, monospace; font-size: 1.1em;"><u>My heading</u></pre><p>If we now change the text to:</p><pre style="font-family: 'Courier New', Courier, monospace; font-size: 1.1em;"><u>Your heading</u></pre><p>the underline will automatically be updated by the editor, which solves our coordination problem through <em>automation</em> by the computer.</p><p>This correlation could be expressed with something like &quot;when the heading is changed, make sure the corresponding row below has the same number of characters&quot;. This is something that a person could be responsible for, but it could also be delegated to, and <em>automated by</em>, a computer.</p><p>Note that we can&apos;t get rid of all manual work. Automation needs code, written by humans! Of course it&apos;s only a matter of time until even that task has also been taken over by computers, but that&apos;s another story!</p><h2 id="changeability">Changeability</h2><p>When we work with software, we have to deal with the fact that most things around us constantly change.</p><p>That include hardware, protocols, data formats, security standards, operating systems, programming languages, libraries, frameworks, code, tooling, services, methodologies, staff, organisations, and not least ourselves!</p><p>I would argue that <em>changeability</em> is the most important feature of software to fight complexity. If we could find a simple model that is based on simple principles, then we have something useful that will help us create simpler systems.</p><p>This is what we need to do to achieve <em>changeability</em>:</p><ul><li>Increase usability</li><li>Reduce coordination</li></ul><h3 id="usability">Usability</h3><p>Making things <em>usable</em> can be achieved by adapting our systems and tools to people and their limitations and needs. Code is no exception!</p><p>The level of usability of a codebase or part of a codebase has a direct correlation with how easy it is to change.</p><p>Here is what Wikipedia says about <a href="https://en.wikipedia.org/wiki/Usability">usability</a>:</p><blockquote><p><strong>Usability</strong> is the ease of use and learnability of a human-made object such as a tool or device. In <a href="https://en.wikipedia.org/wiki/Software_engineering">software engineering</a>, <strong>usability</strong> is the degree to which a software can be used by specified consumers to achieve quantified objectives with effectiveness, efficiency, and satisfaction in a quantified context of use.</p></blockquote><p>The main ways of achieving usability in software are:</p><ol><li>Make things easy to find, reuse and reason about.</li><li>Use tools and techniques that let you work fast and give you a fast feedback loop.</li><li>Organise people so that you facilitate communication, learning and craftsmanship.</li></ol><p>Usability can be increased in many ways. Here are three examples:</p><p><strong>Example 1:</strong> Give things a good name.</p><p><strong>Example 2:</strong> Use a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> to increase the productivity by shortening the feedback loop.</p><p><strong>Example 3:</strong> Agree on a <a href="https://martinfowler.com/bliki/UbiquitousLanguage.html">ubiquitous language</a> when communicating.</p><p>There is a lot to say about usability but it&apos;s a huge research area of its own which we will not delve into here.</p><h3 id="coordination">Coordination</h3><p>We have already said that coordination increases complexity and given some examples of it but we haven&apos;t looked into what causes it or where it arises.</p><h4 id="cause-of-coordination">Cause of coordination</h4><p>There are three main areas that introduce the need for coordination:</p><ul><li><em>Size</em> — when things get bigger</li><li><em>Order</em> — when order matters</li><li><em>Consistency</em> — when consistency matters</li></ul><h4 id="cause-of-coordination-—-size">Cause of coordination — Size</h4><p>When something gets bigger it doesn&apos;t just have a negative effect on the <em>usability</em>; by making things harder to understand and reason about, it also increases the need for <em>coordination</em>.</p><p>There are essentially two ways to minimise size:</p><ul><li><em>Split it up</em> — to reduce coordination</li><li><em>Make it composable</em> — to make it smaller and easier to use</li></ul><p><strong>Split it up</strong></p><p>For example, if we <em>double</em> the number of people in a team by going from three to six people:</p><img src="assets/2019-09-14-the-origin-of-complexity/connections.webp" alt="Visualization of team communication connections" style="width: 80%; max-width: 336px; height: auto;"><p>The number of ways to communicate increases from three to fifteen, which is a factor of 5! This <em>exponential growth</em> of <em>coordination</em> and <em>complexity</em> is one of the hardest problems to tackle in software. This unfortunate behaviour is the reason why some <a href="https://en.wikipedia.org/wiki/List_of_failed_and_overbudget_custom_software_projects">large projects fail</a>.</p><p>The way to fight complexity is to split things up:</p><img src="assets/2019-09-14-the-origin-of-complexity/split-it-up.webp" alt="Visualization of splitting teams to reduce coordination" style="width: 80%; max-width: 336px; height: auto;"><p>Here we have two teams of three people, where one person in each team is responsible for communicating with the other team and its own. This has reduced the number of connections from 15 to 7, which is more than a 50% reduction in coordination!</p><p>The same principles apply to code and data which is why it&apos;s better to have small functions than big ones and why a <a href="https://polylith.gitbook.io/polylith">Polylith</a> system made up of small reusable components is preferable to a big <a href="https://en.wikipedia.org/wiki/Monolithic_application">Monolith</a>.</p><p><strong>Make it composable</strong></p><p>The other main technique to reduce size is by making things <em>composable</em>.</p><p>To achieve <em>composability</em> we have to introduce <em>conformity</em> in the way we process things:</p><img src="assets/2019-09-14-the-origin-of-complexity/composability.webp" alt="Visualization of composability and conformity" style="width: 100%; max-width: 469px; height: auto;"><p>The <a href="https://en.wikipedia.org/wiki/Functional_programming">functional</a> way is to have <em>data</em> as material and <em>functions</em> as tools. The <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">object oriented</a> way is to have <em>data</em> or <em>interfaces</em> as material and <em>objects</em> as tools.</p><p>To make this useful we need to reduce the number of variants of <em>material</em> and make sure the <em>tools</em> can operate on it. As long as that is met, we can allow ourself to have a large set of tools as a way to reduce complexity.</p><p>In Unix, the material consists of <em>lines of strings</em> and the tools are represented by a set of <em>commands</em> which can be combined together like LEGO©:</p><pre><code class="language-bash">tr -cs A-Za-z &apos;\n&apos; | 
tr A-Z a-z | 
sort | 
uniq -c | 
sort -rn | 
sed ${1}q
</code></pre><p style="margin-top: 0.5em; margin-bottom: 0; line-height: 0.5em;">&nbsp;</p><p>This example was taken from a solution that <a href="https://en.wikipedia.org/wiki/Douglas_McIlroy">Douglas McIlroy</a> wrote when he gave feedback to <a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>. You can read more about the background <a href="https://franklinchen.com/blog/2011/12/08/revisiting-knuth-and-mcilroys-word-count-programs/">here</a> and also find a <a href="https://rosettacode.org/wiki/Word_frequency#Clojure">list with solutions</a> to the problem written in different languages.</p><h4 id="cause-of-coordination-—-order">Cause of coordination — Order</h4><p>One source of complexity is when we need to coordinate the <em>order</em> in which things happen.</p><p>Sometimes it&apos;s important that things come in a certain order. Code is no exception:</p><img src="assets/2019-09-14-the-origin-of-complexity/order.webp" alt="Visualization of order and coordination" style="width: 80%; max-width: 336px; height: auto;"><p>Here <em>statement 2</em> must wait for <em>statement 1</em> to finish, which has introduced need for coordination between the two statements. The result is that we can&apos;t swap the order or parallelise the statements.</p><p>Sometimes one thing has to happen before another. In those cases, it&apos;s helpful if that is explicitly expressed, by the code, the planning tool, or whatever tool we use. But if the need for coordination is not clearly expressed, which is often the case with code, then you run an increased risk of introducing errors.</p><p>The solution is to separate <em>what</em> from <em>how</em>. If we can express <em>what</em> needs to be done and delegate <em>how</em> to some other parts, like a function, a queue, a rule engine or a <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> engine, then we are in a much better position to care less about the execution order.</p><p>Let&apos;s give some examples where the <em>order</em> is important:</p><p><strong>Example 1:</strong> We plan our work before we start working.</p><p><strong>Example 2:</strong> An <em>init</em> function must be called, before proceeding with other work (temporal coupling).</p><p><strong>Example 3:</strong> A server must be installed with an operating system, a virtual machine, some tools and such, before other software can run on it.</p><p><strong>Example 4:</strong> We learn and practice to achieve craftsmanship before we can perform tasks.</p><p>Some of these tasks, like setting up a server, can be automated which is the way we <em>reduce coordination</em>. Other tasks can&apos;t be fully automated, at least not yet, like planning, learning and practising.</p><h4 id="cause-of-coordination-—-consistency">Cause of coordination — Consistency</h4><p>The last thing on our list that causes coordination is when things need to be consistent. We live in a changing world, and things can very easily &quot;get out of sync&quot;. Another challenge is to avoid duplication.</p><p>There are essentially two ways to keep things in sync:</p><ul><li><em>Have only one of things</em></li><li><em>Move in small steps</em></li></ul><p><strong>Have only one</strong></p><p>An efficient way to ensure that things are consistent is to only have <em>one of everything</em>. The instructions and functions that are part of a programming language are good examples.</p><p>Each &quot;building block&quot;, like an <em>if</em> statement, is only defined <em>once</em>, but can be used from more than one place in the code:</p><img src="assets/2019-09-14-the-origin-of-complexity/have-only-one.webp" alt="Visualization of having only one definition used in multiple places" style="width: 96%; max-width: 403px; height: auto;"><p>The language itself is also only defined once, but can be used from several places (on different machines). The way we get rid of coordination is to only need to make changes in <em>one place</em>.</p><p>If we have some code or data that is copied and used in more than one place (e.g. two different services) then we have introduced <em>duplication</em> that needs to be <em>coordinated</em> to stay in sync and remain <em>consistent</em>:</p><img src="assets/2019-09-14-the-origin-of-complexity/coordination.webp" alt="Visualization of duplication requiring coordination" style="width: 70%; max-width: 294px; height: auto;"><p>If we later need to change one of them, e.g. to fix a bug, then we also need to remember to update the other service. The idea that <em>copy&amp;paste</em> can be used to &quot;decouple&quot; services is often an illusion, because it doesn&apos;t remove the <em>need for coordination</em>.</p><p>Sometimes though, you really want to start from scratch. An example is when the <a href="https://www.mysql.com/">MySql</a> database was forked to become <a href="https://mariadb.org/">MariaDB</a>.</p><p>Another example of removing coordination by centralising a definition into one place, is the use of <em>polymorphism</em>:</p><img src="assets/2019-09-14-the-origin-of-complexity/dispatch.webp" alt="Visualization of polymorphism and dispatch mechanism" style="width: 72%; max-width: 302px; height: auto;"><p>In object orientation, the choice of method to call when invoking a method on an object is based on the type of its class. Functional languages sometimes support an even <a href="https://clojure.org/reference/multimethods">more flexible</a> way of dispatching calls, but the principle is the same.</p><p>The idea is to centralise the dispatching mechanism into <em>one place</em> so that we don&apos;t end up with duplicated <em>if</em> or <em>case</em> statements scattered around the codebase, that then need coordination.</p><p><strong>Move in small steps</strong></p><p>The most common example of when things get <em>out of sync</em> is when people, tools, code, models, hardware, and so on, don&apos;t move with their surroundings.</p><p>The way to tackle the problem is to <em>move in small steps</em>.</p><p>The reason we want to move in small steps, like making small commits in our <a href="https://en.wikipedia.org/wiki/Version_control">VCS</a> system or by having short <a href="https://www.scrum.org/resources/what-is-a-sprint-in-scrum">sprints</a>, is that the amount of coordination we need to do when &quot;merging back&quot; increases exponentially with the size of the &quot;diff&quot;:</p><img src="assets/2019-09-14-the-origin-of-complexity/merge.webp" alt="Visualization of merging and coordination" style="width: 100%; max-width: 437px; height: auto;"><p>The more often we can merge back our code into master, the less coordination needs to be done. The shorter sprints we have, the easier it is to stay in sync with a changing world (the &quot;master&quot; branch).</p><h4 id="where-coordination-arises">Where coordination arises</h4><p>We mentioned that many things are constantly changing when developing software. Changes introduce the <em>need for coordination</em> which is one of the main reasons why building software is so hard.</p><p>As we can see, coordination is going on at all levels:</p><img src="assets/2019-09-14-the-origin-of-complexity/where-coordination-arises.webp" alt="Visualization of where coordination arises" style="width: 100%; max-width: 568px; height: auto;"><ol><li><em>Hardware &amp; network</em> are affected by the <em>reality</em> so that they sometimes break and need to be repaired or replaced.</li><li>Concepts from <em>the world</em> become <em>models</em> in our code.</li><li><em>People</em> are affected by <em>the world</em> and the environment they live and work in.</li><li><em>People</em> leave teams/projects and new <em>people</em> appear.</li><li><em>Tools &amp; services</em> are used to manage <em>hardware &amp; network</em>. Sometimes <em>manually</em> by <em>people</em> that use <em>tools</em> and sometimes <em>automated</em>.</li><li><em>Tools</em> are used to execute or debug <em>runtime code</em>.</li><li><em>Tools &amp; services</em> are made up of <em>runtime code</em> so that they can be executed.</li><li><em>Hardware</em> is needed to execute <em>runtime code</em>.</li><li><em>Source code</em> is transformed into <em>runtime code</em>.</li><li><em>Tools</em> are used to work with <em>source code</em>.</li><li><em>Tools</em> are used by other <em>tools &amp; services</em>.</li><li><em>People</em> create <em>tools &amp; services</em>.</li><li><em>People</em> interact with other <em>people</em>.</li><li><em>Models</em> affect how the <em>source code</em> is written.</li><li><em>Tools</em> are used to create <em>models</em>.</li><li><em>Tools and services</em> are used by <em>people</em> to perform tasks: 5) manage hardware &amp; network, 6) execute or debug code, 10) work with source code, 15) create models, 16) organise people.</li></ol><p>There is a massive amount of coordination going on here. If we make a change in one place, it will often start a ripple effect of changes in other parts.</p><p>The ways in which we manage all these changes are:</p><ul><li>Increase usability</li><li>Automate and minimise coordination</li></ul><p>We have already talked about how to automate coordination and that usability affects changeability. But what we haven&apos;t mentioned yet is that we sometimes have the choice to <em>not change at all</em> or to only make <em>non-breaking changes</em>.</p><p>Here are some examples:</p><p><strong>Example 1:</strong> The original <a href="https://en.wikipedia.org/wiki/X86">Intel x86</a> instruction set is still supported, decades after it was first released.</p><p><strong>Example 2:</strong> The original bytecode instruction set for the <a href="https://en.wikipedia.org/wiki/Java_virtual_machine">Java Virtual Machine</a> is still supported.</p><p><strong>Example 3:</strong> The original <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a> protocol specification is still supported, more than four decades later.</p><p>The solution is to agree on a contract, make it into a standard, and then only make backward compatible changes. Simple as that!</p><p>These standards are globally shared, but we can use the same idea within an organisation or a codebase, by e.g. saying that we always use <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> when communicating between services, or that all code should run on top of the <a href="https://en.wikipedia.org/wiki/.NET_Framework">.Net</a> or the <a href="https://en.wikipedia.org/wiki/Java_virtual_machine">JVM</a> platform to ensure consistency.</p><h2 id="out-of-the-tar-pit">Out of the Tar Pit</h2><p>Before we continue, we need to mention the masterpiece <a href="http://curtclifton.net/papers/MoseleyMarks06a.pdf">Out of the Tar Pit</a> by Ben Moseley and Peter Marks. The reason is simple. It would be a crime to not include it in a blog post about <em>complexity</em> in software!</p><p>If you haven&apos;t read it already, I recommend that you do. It&apos;s well spent time!</p><p>They talk a lot about the importance of fighting complexity and where it arises.</p><p>They state that:</p><blockquote><p>Complexity is the single major difficulty in the successful development of large-scale software systems.</p></blockquote><p>They continue:</p><blockquote><p>We believe that the major contributor to this complexity in many systems is the handling of state</p></blockquote><p>With <em>state</em> they mean <em>mutable state</em>, especially <em>uncoordinated mutable state</em>. I agree that this is very much true, especially in languages that encourage use of <em>uncoordinated mutable state</em>.</p><p>The reason why <em>mutable state</em> is especially hard to deal with, is that it introduces the <em>need for coordination</em>. Sometimes this need for coordination is lacking, as in the case of <em>global variables</em>, which is why global variables are discouraged in general.</p><p>Luckily, there are ways of controlling mutable state, like the use of <a href="https://en.wikipedia.org/wiki/Transaction_processing">transactions</a>, <a href="https://clojure.org/reference/transients">transient data structures</a>, <a href="https://en.wikipedia.org/wiki/Software_transactional_memory">software transactional memory (stm)</a>, <a href="https://clojure.org/reference/atoms">atoms</a>, and more.</p><p>A common situation where mutable state can sneak in is via use of objects:</p><blockquote><p>The bottom line is that all forms of OOP rely on state (contained within objects) and in general all behaviour is affected by this state. As a result of this, OOP suffers directly from the problems associated with state described above, and as such we believe that it does not provide an adequate foundation for avoiding complexity.</p></blockquote><p>This is also why the use of <em>immutable state</em> and <em>pure functions</em> is preferred, because they don&apos;t introduce coordination by themselves.</p><p>The paper also talks about complexity caused by <em>control</em>, which is about the <em>order</em> in which things happen.</p><p>Their observation is that:</p><blockquote><p>ordering in which things will happen is controlled by the order in which the statements of the programming language are written</p></blockquote><p>The problem with this is that it adds need for coordination that is not explicitly expressed by the language with the result that the developers need to perform this coordination in their head when they read the code, which increases the risk of introducing errors in the code.</p><p>They describe it very well on page 8 and 9:</p><blockquote><p>The difficulty is that when control is an implicit part of the language (as it almost always is), then every single piece of program must be understood in that context — even when (as is often the case) the programmer may wish to say nothing about this. When a programmer is forced (through use of a language with implicit control flow) to specify the control, he or she is being forced to specify an aspect of how the system should work rather than simply what is desired. Effectively they are being forced to over-specify the problem.</p></blockquote><p>The paper discusses many other aspects of software, like identity, different kinds of programming paradigms, the relational model, and more. I think if more people understood this paper, much of the complexity that is produced in this industry could be eliminated!</p><h2 id="dependencies">Dependencies</h2><p>So why use the word <em>coordination</em> when we already have <em>dependency</em>?</p><p>The main reason is that they <em>mean different things</em>.</p><p>That&apos;s also why we can&apos;t say &quot;dependencies are bad&quot;, because it&apos;s not always the case. It&apos;s especially not true if we depend on something that never changes in a breaking way.</p><p>For example, depending on a Virtual Machine (e.g. the JVM) helps us eliminate the need for coordination between the compiled bytecode and the hardware. Depending on <code>java.lang.String</code> helps us work with strings in a safe way, without worrying about it changing in the future!</p><p>The rule of thumb is:</p><blockquote><p>Stabilise the things you depend on</p></blockquote><h2 id="coupling">Coupling</h2><p>So if we can&apos;t use <em>dependencies</em> to describe how well a system is designed, maybe we can use <em>coupling</em>?</p><p>Coupling can be described with the <a href="https://en.wikipedia.org/wiki/Connascence">connascence</a> concept, but here we will use the <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">Wikipedia</a> definition:</p><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Software_engineering">software engineering</a>, <strong>coupling</strong> is the degree of interdependence between software modules; a measure of how closely connected two routines or modules are; the strength of the relationships between modules.</p></blockquote><div class="image-with-caption" style="max-width: 524px; margin-top: 30px;">
<img src="assets/2019-09-14-the-origin-of-complexity/coupling.webp" alt="Visualization of coupling and relationships between modules">
<small class="image-caption">https://en.wikipedia.org/wiki/File:Coupling_sketches_cropped_1.svg</small>
</div><p style="margin-top: 30px;"/><p>This illustration measures three aspects of coupling: <em>interdependency</em>, <em>coordination</em> and <em>information flow</em>. If we need three words to describe <em>coupling</em>, where <em>coordination</em> is one of them, then it&apos;s probably not the same concept as <em>coordination</em>!</p><p>An indication that the concept is not so concisely defined is the huge list of different types of coupling: <em>content coupling</em>, <em>common coupling</em>, <em>external coupling</em>, <em>control coupling</em>, <em>stamp coupling</em>, <em>data coupling</em>, <em>subclass coupling</em>, and <em>temporal coupling</em>.</p><p>The underlying mechanisms that contribute to complexity are not clearly expressed, which makes the concept of <em>loose</em> or <em>tight coupling</em> hard to use as a tool to guide us when making design decisions.</p><p>The consequence is that people often try to &quot;decouple&quot; things without decreasing the need for coordination, which unfortunately often only adds more complexity. A better approach is instead to focus on <em>reducing coordination</em> and <em>increasing usability</em> as a way to fight complexity.</p><h2 id="tradeoffs">Tradeoffs</h2><p>Sometimes you may have to chose between a <em>usable</em> solution that introduces <em>coordination</em> and a solution that does the opposite.</p><p>Let&apos;s assume you need to choose between introducing duplications in a text file, or using a <a href="https://en.wikipedia.org/wiki/Template_processor">template engine</a>:</p><img src="assets/2019-09-14-the-origin-of-complexity/tradeoffs.webp" alt="Visualization of tradeoffs between solutions" style="width: 100%; max-width: 530px; height: auto;"><p>To store the content as <em>plain text</em> keeps it readable and search-able, but with the extra cost of remembering to update the file whenever the duplicated content changes.</p><p>Introducing a <em>template engine</em> will solve the <em>coordination</em> of the otherwise duplicated content, but will also add complexity and maybe reduce readability and search-ability.</p><p>What solution to choose should be based on how often the duplicated data changes, the risk of forgetting to update the file and how big an impact that may have compared to the cost of introducing a template engine.</p><p>Most often though, a reduction in <em>coordination</em> also has a positive effect on the <em>usability</em>:</p><img src="assets/2019-09-14-the-origin-of-complexity/changeability.webp" alt="Visualization of changeability and coordination vs usability" style="width: 100%; max-width: 530px; height: auto;"><p>That includes reducing the <em>size</em>, removing <em>duplication</em>, separating <em>what</em> from <em>how</em>, keeping things <em>consistent</em>, and more.</p><h2 id="summary">Summary</h2><p>This diagram summarises what we have talked about:</p><img src="assets/2019-09-14-the-origin-of-complexity/summary.webp" alt="Summary diagram of coordination and usability" style="width: 100%; max-width: 823px; height: auto;"><p>This diagram will help you develop the <em>thing right</em> but not the <em>right thing</em>. That part you have to figure out yourself!</p><p>The goal is to give you a tool that guides you towards simpler solutions with increased quality in a way that allows you to work fast, have more fun and spend less money!</p><p>So don&apos;t hesitate to use dm the next time you need to make a design decision!</p><h2 id="choice-of-programming-language">Choice of programming language</h2><p>Our most important tool in our toolkit is the <em>programming language</em>. People often say that it doesn&apos;t matter what programming language we choose, because we can solve any problem regardless of choice of language, as long as it&apos;s fast enough and <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a>.</p><p>This is as wrong as saying that it doesn&apos;t matter how skilled the players in a football team are. It may be a poor comparison, but programming languages also need &quot;skills&quot; to perform well!</p><p>Sometimes the speed of the language or how fast it compiles is the most important skill, but most often it&apos;s just about how well it&apos;s suited to fight complexity.</p><p>When we make our choice of language, we should pick one that ticks as many boxes in the <em>Simplicity</em> column as possible:</p><img src="assets/2019-09-14-the-origin-of-complexity/whats-in-your-toolkit.webp" alt="What's in your toolkit diagram" style="width: 100%; max-width: 686px; height: auto;"><p>If this diagram looks familiar to you, then it&apos;s because it&apos;s taken from the brilliant talk <a href="https://www.infoq.com/presentations/Simple-Made-Easy/">Simple Made Easy</a> by <a href="https://github.com/tallesl/Rich-Hickey-fanclub">Rich Hickey</a>.</p><p>Don&apos;t forget that the choice of programming language is not just a matter of taste, it&apos;s an opportunity to choose the best tool for the job to fight complexity.</p><p>If your favourite language doesn&apos;t tick that many boxes, then it can be an idea to look around and see if you can find <a href="https://clojure.org/">one that does</a>!</p><p>Let the war against complexity begin.</p><p>Happy coding!</p><hr /><p><em>Originally published on <a href="https://itnext.io/the-origin-of-complexity-8ecb39130fc">ITNEXT</a></em></p></div>]]></content>
  </entry>
  <entry>
    <id>https://tengstrand.github.io/blog/2018-10-02-the-polylith-architecture.html</id>
    <link href="https://tengstrand.github.io/blog/2018-10-02-the-polylith-architecture.html"/>
    <title>The Polylith architecture</title>
    <updated>2018-10-02T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<div><img src="assets/2018-10-02-the-polylith-architecture/polylith-text-and-logo.webp" alt="Polylith architecture logo" style="width: 400px; max-width: 100%; display: block; margin: 30px 0;" /><p>Today I&apos;m proud to announce a new software architecture, called Polylith!<sup id="fnref:1"><a href="#fn:1" class="footnote-ref">1</a></sup></p><p>I hope that Polylith can have a positive affect on the software industry, by focusing on simplicity and developer happiness and efficiency.</p><p>Let’s start from the beginning. Two years ago I finally had the chance to work full time with the functional language <a href="https://en.wikipedia.org/wiki/Clojure">Clojure</a> and the functional database <a href="https://www.datomic.com/">Datomic</a>. I had read a book, blogged and played around with the language for a while, but now it was time to leave 20 years of Java behind me.</p><p>I joined a small team with one developer, a team leader and a UX designer. Even though only the team leader and I had any previous experience with Clojure and very little experience with Datomic, the whole team was up and running quickly and very soon became a hyper productive Dream Team!</p><p>A fantastic thing about Clojure is its <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>. It allows you to work much faster compared to “up front” compiled languages like Java. Instead, it compiles the code incrementally. The result is lightning fast feedback, where you have direct access to all your data and compiled code. Once you have tried it, you will never look back!</p><p>After a month I questioned why we still had a Microservices architecture. It slowed us down because we now had a bunch of <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>s instead of just one, and it also added a lot of boilerplate code and unnecessary complexity.</p><p>One morning on the train to work I got that eureka moment that you may get once in a lifetime. I realised that the solution was to turn the development environment into a monolith using <a href="https://en.wikipedia.org/wiki/Symbolic_link">symbolic links</a><sup id="fnref:2"><a href="#fn:2" class="footnote-ref">2</a></sup> to each &quot;component&quot;! This little trick worked out well and now we had our single REPL back again!</p><div class="image-with-caption" style="max-width: 600px;">
<img src="assets/2018-10-02-the-polylith-architecture/polylith-building-blocks.webp" alt="The three building blocks of Polylith">
<small class="image-caption">The three building blocks of Polylith</small>
</div><p style="margin-top: 30px;"/><p>Two years have passed and we still love this way of designing systems. The components have become our friends that are easy to understand, reuse and combine into deployable systems. The <a href="https://github.com/polyfy/polylith">tool</a> helps us test and build our systems incrementally both locally and on the continuous integration server.</p><p>It’s not just efficient and fun, it has changed the way we think about design at the system level.</p><p>If this has made you curious, then head over to our <a href="https://polylith.gitbook.io/">high-level documentation</a> to find out more.</p><p>Happy coding!</p><p>Joakim Tengstrand</p><div class="footnotes">
<ol>
<li id="fn:1">
<p>
The predecessor to Polylith was called <a href="https://medium.com/@joakimtengstrand/the-micro-monolith-architecture-d135d9cafbe">Micro Monolith</a>, and if you look closely you will also notice that the logo has changed since this was posted: <img src="assets/2018-10-02-the-polylith-architecture/polylith-logo.png" alt="Polylith logo" style="width: 24px; height: 24px; vertical-align: middle; display: inline-block; margin: 0 2px;">
<a href="#fnref:1" class="footnote-backref">↩</a>
</p>
</li>
<li id="fn:2">
<p>
Since October 2020, the new <a href="https://cljdoc.org/d/polylith/clj-poly/CURRENT">poly command line tool</a> uses <a href="https://clojure.org/guides/deps_and_cli">tools.deps</a> instead of <a href="https://en.wikipedia.org/wiki/Symbolic_link">symbolic links</a>.
<a href="#fnref:2" class="footnote-backref">↩</a>
</p>
</li>
</ol>
</div></div>]]></content>
  </entry>
</feed>
